#!/usr/bin/env bash
#
#         _       _
#        | |     | |
#      __| | ___ | |_ ___
#     / _` |/ _ \| __/ __|
#    | (_| | (_) | |_\__ \
#     \__,_|\___/ \__|___/
#
#
# A configuration management tool for your personal unix-like computer.
#
# Copyright (c) 2015 William Melody â€¢Â hi@williammelody.com

###############################################################################
# Strict Mode
###############################################################################

# Treat unset variables and parameters other than the special parameters â€˜@â€™ or
# â€˜*â€™ as an error when performing parameter expansion. An 'unbound variable'
# error message will be written to the standard error, and a non-interactive
# shell will exit.
#
# This requires using parameter expansion to test for unset variables.
#
# http://www.gnu.org/software/bash/manual/bashref.html#Shell-Parameter-Expansion
#
# The two approaches that are probably the most appropriate are:
#
# ${parameter:-word}
#   If parameter is unset or null, the expansion of word is substituted.
#   Otherwise, the value of parameter is substituted. In other words, "word"
#   acts as a default value when the value of "$parameter" is blank. If "word"
#   is not present, then the default is blank (essentially an empty string).
#
# ${parameter:?word}
#   If parameter is null or unset, the expansion of word (or a message to that
#   effect if word is not present) is written to the standard error and the
#   shell, if it is not interactive, exits. Otherwise, the value of parameter
#   is substituted.
#
# Examples
# ========
#
# Arrays:
#
#   ${some_array[@]:-}              # blank default value
#   ${some_array[*]:-}              # blank default value
#   ${some_array[0]:-}              # blank default value
#   ${some_array[0]:-default_value} # default value: the string 'default_value'
#
# Postitional variables:
#
#   ${1:-alternative} # default value: the string 'alternative'
#   ${2:-}            # blank default value
#
# With an error message:
#
#   ${1:?'error message'}  # exit with 'error message' if variable is unbound
#
# Short form: set -u
set -o nounset

# Exit immediately if a pipeline returns non-zero.
#
# NOTE: this has issues. When using read -rd '' with a heredoc, the exit
# status is non-zero, even though there isn't an error, and this setting
# then causes the script to exit. read -rd '' is synonymous to read -d $'\0',
# which means read until it finds a NUL byte, but it reaches the EOF (end of
# heredoc) without finding one and exits with a 1 status. Therefore, when
# reading from heredocs with set -e, there are three potential solutions:
#
# Solution 1. set +e / set -e again:
#
# set +e
# read -rd '' variable <<EOF
# EOF
# set -e
#
# Solution 2. <<EOF || true:
#
# read -rd '' variable <<EOF || true
# EOF
#
# Solution 3. Don't use set -e or set -o errexit at all.
#
# More information:
#
# https://www.mail-archive.com/bug-bash@gnu.org/msg12170.html
#
# Short form: set -e
set -o errexit

# Return value of a pipeline is the value of the last (rightmost) command to
# exit with a non-zero status, or zero if all commands in the pipeline exit
# successfully.
set -o pipefail

# Set IFS to just newline and tab at the start
#
# http://www.dwheeler.com/essays/filenames-in-shell.html
#
# $DEFAULT_IFS and $SAFER_IFS
#
# $DEFAULT_IFS contains the default $IFS value in case it's needed, such as
# when expanding an array and you want to separate elements by spaces.
# $SAFER_IFS contains the preferred settings for the program, and setting it
# separately makes it easier to switch between the two if needed.
#
# NOTE: also printing $DEFAULT_IFS to /dev/null to avoid shellcheck warnings
# about the variable being unused.
DEFAULT_IFS="$IFS"; printf "%s" "$DEFAULT_IFS" > /dev/null
SAFER_IFS="$(printf '\n\t')"
# Then set $IFS
IFS="$SAFER_IFS"

###############################################################################
# .dotsrc
###############################################################################

# If a dotsrc file exists in $HOME, source it.
dotsrc="$HOME/.dotsrc"
if [[ -e "$dotsrc" ]]; then
  source "$dotsrc"
fi

###############################################################################
# Globals
###############################################################################

DOTS_VERSION="5.0.0-alpha"

# Set dotfiles if not already set.
if [[ -z ${DOTSPATH:-} ]]; then
  DOTSPATH="$HOME/.dots"
fi

###############################################################################
# Debug
###############################################################################

# _debug()
#
# A simple function for executing a specified command if the `$_USE_DEBUG`
# variable has been set. The command is expected to print a message and
# should typically be either `echo`, `printf`, or `cat`.
#
# Usage:
#   _debug printf "Debug info. Variable: %s\n" "$0"
_debug() {
  if [[ "${_USE_DEBUG:-"0"}" -eq 1 ]]; then
    # Prefix debug message with "bug (U+1F41B)"
    printf "ðŸ›  "
    "$@"
    printf "â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•â€•\n"
  fi
}
# debug()
#
# Print the specified message if the `$_USE_DEBUG` variable has been set.
#
# This is a shortcut for the _debug() function that simply echos the message.
#
# Usage:
#   debug "Debug info. Variable: $0"
debug() {
  _debug echo "$@"
}

###############################################################################
# Die
###############################################################################

# _die()
#
# A simple function for exiting with an error after executing the specified
# command. The command is expected to print a message and should typically
# be either `echo`, `printf`, or `cat`.
#
# Usage:
#   _die printf "Error message. Variable: %s\n" "$0"
_die() {
  # Prefix die message with "cross mark (U+274C)", often displayed as a red x.
  printf "âŒ  "
  "$@" 1>&2
  exit 1
}
# die()
#
# Exit with an error and print the specified message.
#
# This is a shortcut for the _die() function that simply echos the message.
#
# Usage:
#   die "Error message. Variable: $0"
die() {
  _die echo "$@"
}

###############################################################################
# Options
###############################################################################

# Get raw options for any commands that expect them.
_RAW_OPTIONS="$*"

# Steps:
#
# 1. set expected short options in `optstring` at beginning of the "Normalize
#    Options" section,
# 2. parse options in while loop in the "Parse Options" section.

# Normalize Options ###########################################################

# Source:
#   https://github.com/e36freak/templates/blob/master/options

# The first loop, even though it uses 'optstring', will NOT check if an
# option that takes a required argument has the argument provided. That must
# be done within the second loop and case statement, yourself. Its purpose
# is solely to determine that -oARG is split into -o ARG, and not -o -A -R -G.

# Set short options -----------------------------------------------------------

# option string, for short options.
#
# Very much like getopts, expected short options should be appended to the
# string here. Any option followed by a ':' takes a required argument.
#
# In this example, `-x` and `-h` are regular short options, while `o` is
# assumed to have an argument and will be split if joined with the string,
# meaning `-oARG` would be split to `-o ARG`.
optstring=h

# Normalize -------------------------------------------------------------------

# iterate over options, breaking -ab into -a -b and --foo=bar into --foo bar
# also turns -- into --endopts to avoid issues with things like '-o-', the '-'
# should not indicate the end of options, but be an invalid option (or the
# argument to the option, such as wget -qO-)
unset options
# while the number of arguments is greater than 0
while (($#)); do
  case $1 in
    # if option is of type -ab
    -[!-]?*)
      # loop over each character starting with the second
      for ((i=1; i<${#1}; i++)); do
        # extract 1 character from position 'i'
        c=${1:i:1}
        # add current char to options
        options+=("-$c")

        # if option takes a required argument, and it's not the last char
        # make the rest of the string its argument
        if [[ $optstring = *"$c:"* && ${1:i+1} ]]; then
          options+=("${1:i+1}")
          break
        fi
      done
      ;;
    # if option is of type --foo=bar, split on first '='
    --?*=*) options+=("${1%%=*}" "${1#*=}");;
    # end of options, stop breaking them up
    --)
      options+=(--endopts)
      shift
      options+=("$@")
      break
      ;;
    # otherwise, nothing special
    *) options+=("$1");;
  esac

  shift
done
# set new positional parameters to altered options. Set default to blank.
set -- "${options[@]:-}"
unset options

# Parse Options ###############################################################

# Initialize $_COMMAND_ARGV array
#
# This array contains all of the arguments that get passed along to each
# command. This is essentially the same as the program arguments, minus those
# that have been filtered out in the program option parsing loop. This array
# is initialized with $0, which is the program's name.
_COMMAND_ARGV=("$0")
# Initialize `$_CMD` and `$_USE_DEBUG`, which can continue to be blank
# depending on what the program needs.
_CMD=""
_USE_DEBUG=0

while [ $# -gt 0 ]; do
  opt="$1"
  shift
  case "$opt" in
    -h|--help)
      _CMD="help"
      ;;
    --version)
      _CMD="version"
      ;;
    --debug)
      _USE_DEBUG=1
      ;;
    bin|home)
      # If an argument prior to the command name is either 'bin' or 'home', set
      # that as the context. Otherwise, if the command has already been set,
      # then any matches are assumed to be command arguments.
      if [[ -z $_CMD ]]; then
        context="$opt"
      else
        _COMMAND_ARGV+=("$opt")
      fi
      ;;
    *)
      # The first non-context argument encountered is assumed to be the command
      # name, and all subsequent arguments are set as command arguments.
      if [[ -n $_CMD ]]; then
        _COMMAND_ARGV+=("$opt")
      else
        _CMD=$opt
      fi
      ;;
  esac
done

# If no context was set from the options, default to 'home'.
if [[ -z "${context:-}" ]]; then
  context="home"
fi

# Set $_COMMAND_PARAMETERS to $_COMMAND_ARGV, minus the initial element, $0. This
# provides an array that is equivalent to $* and $@ within each command
# function, though the array is zero-indexed, which could lead to confusion.
_COMMAND_PARAMETERS=("${_COMMAND_ARGV[@]:1}")

_debug printf "\$context: %s\n" "$context"
_debug printf "\$_CMD: %s\n" "$_CMD"
_debug printf "\$_RAW_OPTIONS (one per line):\n%s\n" "$_RAW_OPTIONS"
_debug printf "\$_COMMAND_ARGV: %s\n" "${_COMMAND_ARGV[*]}"
_debug printf "\$_COMMAND_PARAMETERS: %s\n" "${_COMMAND_PARAMETERS[*]:-}"

###############################################################################
# Environment
###############################################################################

# $_ME
#
# Set to the program's basename.
_ME=$(basename "$0")

_debug printf "\$_ME: %s\n" "$_ME"

# $tracked_dir
#
# Set to either 'home' or 'bin' within the dotfiles repository, depending on
# the context.
if [[ "$context" == "bin" ]]; then
  tracked_dir=$DOTSPATH/bin
else
  tracked_dir=$DOTSPATH/home
fi

_debug printf "\$tracked_dir: %s\n" "$tracked_dir"

# $original_dir
#
# Set to either '$HOME/bin' or '$HOME', depending on the context.
if [[ "$context" == "bin" ]]; then
  original_dir=$HOME/bin
else
  original_dir=$HOME
fi

_debug printf "\$original_dir: %s\n" "$original_dir"

# $_git_bin
#
# Must perform git operations via $_git_bin to avoid calling the `dots git`
# command.
_git_bin=$(which git)
if [[ -z "$_git_bin" ]]; then
  _die printf "\
The \`git\` executable can not be found. Since \`dots\` depends on git, \
please install git and make sure it has been added to your \$PATH.\n"
fi

# Set $EDITOR to blank if it's unbound in order to avoid unrelated errors.
#
# There are cases where this can be blank, such as when a shell environment
# is only partially loaded. The only command that currently uses this
# directly handles the blank case by outputting an error, but nothing else
# should be directly impacted by the blank case.
if [[ -z ${EDITOR:-} ]]; then
  EDITOR=
fi

###############################################################################
# Load Commands
###############################################################################

# Initialize $_DEFINED_COMMANDS array.
_DEFINED_COMMANDS=()

# _load_commands()
#
# Loads all of the commands sourced in the environment.
#
# Usage:
#   _load_commands
_load_commands() {

  _debug printf "_load_commands(): entering...\n"
  _debug printf "_load_commands() declare -F:\n%s\n" "$(declare -F)"

  # declare is a bash built-in shell function that, when called with the '-F'
  # option, displays all of the functions with the format
  # `declare -f function_name`. These are then assigned as elements in the
  # $function_list array.
  local function_list=($(declare -F))

  for c in "${function_list[@]}"
  do
    # Each element has the format `declare -f function_name`, so set the name
    # to only the 'function_name' part of the string.
    local function_name
    function_name=$(printf "%s" "$c" | awk '{ print $3 }')

    _debug printf "_load_commands() \$function_name: %s\n" "$function_name"

    # Add the function name to the $_DEFINED_COMMANDS array unless it starts
    # with an underscore or is one of the desc(), debug(), or die() functions,
    # since these are treated as having 'private' visibility.
    if ! ( [[ "$function_name" =~ ^_(.*)  ]] || \
           [[ "$function_name" == "desc"  ]] || \
           [[ "$function_name" == "debug" ]] || \
           [[ "$function_name" == "die"   ]]
    ); then
      _DEFINED_COMMANDS+=("$function_name")
    fi
  done

  _debug printf \
    "commands() \$_DEFINED_COMMANDS:\n%s\n" \
    "${_DEFINED_COMMANDS[*]:-}"
}

###############################################################################
# Main
###############################################################################

# _main()
#
# Usage:
#   _main
#
# The primary function for starting the program.
#
# NOTE: must be called at end of program after all commands have been defined.
_main() {
  _debug printf "main(): entering...\n"
  _debug printf "main() \$_CMD (upon entering): %s\n" "$_CMD"

  # If $_CMD is blank, then set to help
  if [[ -z $_CMD ]]; then
    _CMD="help"
  fi

  # Load all of the commands.
  _load_commands

  # If the command is defined, run it, otherwise return an error.
  if _contains "$_CMD" "${_DEFINED_COMMANDS[*]:-}"; then
    # Pass all comment arguments to the program except for the first ($0).
    $_CMD "${_COMMAND_PARAMETERS[@]:-}"
  else
    _die printf "Unknown command: %s\n" "$_CMD"
  fi
}

###############################################################################
# Utility Functions
###############################################################################

# _each_file()
#
# Iterate over the files in the specified directory and execute the specified
# function.
#
# Usage: _each_file directory function
_each_file() {
  local per_file_function=$2
  if [[ "$context" == "home" ]]; then
    local search_files="$1/.*"
  else
    local search_files="$1/*"
  fi
  for f in $search_files
  do
    local filename
    filename=$(basename "$f")
    local tracked_file=$tracked_dir/$filename
    local original_file=$original_dir/$filename
    if [[ "$context" == "home" ]]; then
      if ! ( [[ "$filename" =~ ^\.?\.$     ]] || \
             [[ "$filename" == ".DS_Store" ]]
      ); then
        # Subfunctions can access the variables in this function, so it's not
        # necessary to pass them as arguments.
        $per_file_function
      fi
    else
      $per_file_function
    fi
  done
}

# _runner()
#
# Run or list scripts in a specified script subdirectory.
#
# Usage: _runner subdirectory ( --all | <list> | <script_name> )
_run_script() {
  local _script="$1"
  local script_arguments=(${@:2})
  if [[ -f "$_script" ]]; then
    printf ">> Running %s\n" "$(basename "$_script")"
    "$_script" "${script_arguments[@]:-}"
  elif [[ -d "$_script" ]]; then
    _die printf "'%s' is a directory.\n" "$_script"
  else
    _die printf "'%s' not found.\n" "$_script"
  fi
}
_runner() {
  [[ -z $1 ]] && _die printf "_runner: No subdirectory specified.\n"
  local subdir=$1
  local subdir_path=$DOTSPATH/script/$subdir
  local script_file=$subdir_path/$2
  local script_arguments=(${@:3})
  if _command_argv_includes "--all"; then
    for f in $subdir_path/*
    do
      if [[ ! -d "$f" ]]; then
        _run_script "$f" "${script_arguments[@]:-}"
      fi
    done
  elif [[ -n "$2" ]]; then
    if [[ "$2" == "list" ]]; then
      for f in $subdir_path/*
      do
        if [[ -f "$f" ]]; then
          basename "$f"
        fi
      done
    else
      _run_script "$script_file" "${script_arguments[@]:-}"
    fi
  else
    _die cat <<EOM
Script must be specified. List available '$subdir' scripts by running:
  $_ME $1 list
EOM
  fi
}

# _each_tracked_file()
#
# Iterate over the files in the tracked directory and execute the specified
# function.
#
# Usage: _each_tracked_file function
_each_tracked_file() {
  _each_file "$tracked_dir" "$1"
}

# _each_original_file()
#
# Iterate over the files in the original directory and execute the specified
# function.
#
# Usage: _each_original_file function
_each_original_file() {
  _each_file "$original_dir" "$1"
}

# _function_exists()
#
# Takes a potential function name as an argument and returns whether a function
# exists with that name.
_function_exists() {
  [ "$(type -t "$1")" == 'function' ]
}

# _contains()
#
# Takes an item and a list and determines whether the list contains the item.
#
# Usage:
#   _contains "$item" "${list[*]}"
_contains() {
  local test_list=(${*:2})
  for _test_element in "${test_list[@]:-}"
  do
    _debug printf "_contains() \$_test_element: %s\n" "$_test_element"
    if [[ "$_test_element" == "$1" ]]; then
      _debug printf "_contains() match: %s\n" "$1"
      return 0
    fi
  done
  return 1
}

# _command_argv_includes()
#
# Takes a possible command argument and determines whether it is included in
# the command argument list.
#
# This is a shortcut for simple cases where a command wants to check for the
# presence of options quickly without parsing the options again.
#
# Usage:
#   _command_argv_includes "an_argument"
_command_argv_includes() {
  _contains "$1" "${_COMMAND_ARGV[*]}"
}

###############################################################################
# desc
###############################################################################

# desc()
#
# Usage:
#   desc command "description"
#
# Create a description for a specified command name. The command description
# text can be passed as the second argument or as standard input.
#
# To make the description text available to other functions, desc() assigns the
# text to a variable with the format $_desc_function_name
#
# NOTE:
#
# The `read` form of assignment is used for a balance of ease of
# implementation and simplicity. There is an alternative assignment form
# that could be used here:
#
# var="$(cat <<'EOM'
# some message
# EOM
# )
#
# However, this form appears to require trailing space after backslases to
# preserve newlines, which is unexpected. Using `read` simply requires
# escaping backslashes, which is more common.
desc() {
  set +e
  [[ -z $1 ]] && _die printf "desc: No command name specified.\n"
  if [[ -n ${2:-} ]]; then
    read -d '' "_desc_$1" <<EOM
$2
EOM
    _debug printf "desc() set with argument: _desc_%s\n" "$1"
  else
    read -d '' "_desc_$1"
    _debug printf "desc() set with pipe: _desc_%s\n" "$1"
  fi
  set -e
}

# _print_desc()
#
# Usage:
#   _print_desc <command>
#
# Prints the description for a given command, provided the description has been
# set using the desc() function.
_print_desc() {
  local var="_desc_$1"
  if [[ -n ${!var:-} ]]; then
    printf "%s\n" "${!var}"
  else
   printf "No additional information for \`%s\`\n" "$1"
  fi
}

###############################################################################
# Default Commands
###############################################################################

# Version #####################################################################

desc "version" <<EOM
Usage:
  $_ME ( version | --version )

Description:
  Display the current program version.

  To save you the trouble, the current version is $DOTS_VERSION
EOM
version() {
  printf "%s\n" "$DOTS_VERSION"
}

# Help ########################################################################

desc "help" <<EOM
Usage:
  $_ME help [<command>]

Description:
  Display help information for $_ME or a specified command.
EOM
help() {
  if [[ ${#_COMMAND_ARGV[@]} = 1 ]]; then
    cat <<EOM
         _       _
        | |     | |
      __| | ___ | |_ ___
     / _\` |/ _ \\| __/ __|
    | (_| | (_) | |_\\__ \\
     \\__,_|\\___/ \\__|___/

A configuration management tool for your personal unix-like computer.

Version: $DOTS_VERSION

Usage:
  $_ME command [--debug] [--command-options] [<arguments>]
  $_ME -h | --help
  $_ME --version

Options:
  --debug    Print debug information.
  -h --help  Display this help information.
  --version  Display version information.

Help:
  $_ME help [<command>]

$(commands)
EOM
 else
  _print_desc "$1"
 fi
}

# Command List ################################################################

desc "commands" <<EOM
Usage:
  $_ME commands [--raw]

Options:
  --raw  Display the command list without formatting.

Description:
  Display the list of available commands.
EOM
commands() {
  if _command_argv_includes "--raw"; then
    printf "%s\n" "${_DEFINED_COMMANDS[@]:-}"
  else
    printf "Available commands:\n"
    printf "  %s\n" "${_DEFINED_COMMANDS[@]:-}"
  fi
}

###############################################################################
# Commands
# ========.....................................................................
#
# Example command group structure:
#
# desc example ""         - Optional. A short description for the command.
# _example_item() { : }   - Optional. A child function to be run for each item.
# example() { : }         - The command called by the user.
#
#
# desc example <<EOM
#   Usage:
#     $_ME example
#
#   Description:
#     List files.
#
#     For usage formatting conventions see:
#     - http://docopt.org/
#     - http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap12.html
# EOM
# _example() {
#   echo $f
#   echo $tracked_file
#   echo $filename
#   echo $original_file
# }
# example() {
#   echo ">> Listing each dotfile in repository"
#   _each_tracked_file _example
#   echo ">> Listing each dotfile in HOME"
#   _each_original_file _example
# }

###############################################################################

# init ########################################################################

# ------------------------------------------------------------------------ init

desc "init" <<EOM
Usage:
  $_ME init [<source_repository>] [<dotspath>] [--initialize-submodules] \
[--skip-dotsrc]

Options:
  --initialize-submodules  Initialize repository submodules when used with a
                           source_repository argument.
  --skip-dotsrc            Don't generate a dotsrc file.

Description:
  Create initial repository file structure and \$HOME/bin if it doesn't exist
  yet.

  When provided with a URL as the first argument or a second argument the git
  repository at that URL is cloned and used as the tracking repository.

  When provided with an absolute path as the lone argument or second argument
  after a repository URL, the initial repository is created at the specified
  path and a configuration file is created at \$HOME/.dotsrc with that location
  set as the \$DOTSPATH.
EOM
# _init_with_source()
#
# Clone a specified URL to a specified path.
#
# called by: init()
_init_with_source() {
  _debug printf "_init_with_source() \$1: %s\n" "$1"
  _debug printf "_init_with_source() \$2: %s\n" "$2"

  if [[ -z "$1" ]]; then
    _die printf "Repository directory not specified.\n"
  elif [[ -z "$2" ]]; then
    _die printf "Source URL not specified.\n"
  else
    $_git_bin clone "$2" "$1"
  fi

  if _command_argv_includes "--initialize-submodules"; then
    cd "$1"
    $_git_bin submodule init
    $_git_bin submodule update --init --recursive
  fi
}
# _init_dotsrc()
#
# Create a file at $HOME/.dotsrc for configuration settings.
#
# called by: init()
_init_dotsrc() {
  _command_argv_includes "--skip-dotsrc" && return 0
  if [[ -n "$1" ]]; then
    printf ">> Adding ~/.dotsrc configuration file.\n"
    printf "\
# .dotsrc
#
# Configuration file for dots
#
# https://github.com/alphabetum/dots

# Set dots directory
export DOTSPATH=\"%s\"
" "$1" >> "$HOME/.dotsrc"
  else
    printf "Repository location not specified.\n"
  fi
}
# _init_directory_structure()
#
# Create an initial directory structure at $DOTSPATH
#
# called by: init()
_init_directory_structure() {
  if [[ -n "$1" ]]; then
    mkdir "$1"
    mkdir "$1/bin"
    touch "$1/bin/.gitkeep"
    mkdir "$1/home"
    # No .gitkeep since all dotfiles in this directory are linked and tracked.
    mkdir "$1/local"
    touch "$1/local/.gitkeep"
    mkdir "$1/script"
    mkdir "$1/script/bootstrap"
    touch "$1/script/bootstrap/.gitkeep"
    mkdir "$1/script/install"
    touch "$1/script/install/.gitkeep"
    mkdir "$1/script/configure"
    touch "$1/script/configure/.gitkeep"
    mkdir "$1/script/customize"
    touch "$1/script/customize/.gitkeep"
  else
    printf "Repository directory not specified.\n"
  fi
}
# _init_gitignore()
#
# Add the default .gitignore to $DOTSPATH/.gitignore
#
# called by: init()
_init_gitignore() {
  if [[ -n "$1" ]]; then
    printf "\
# Ignore the local directory, but track .gitkeep so it's included in the repo.
/local/*
!/local/.gitkeep

# Only track .ssh/config. Everything else in .ssh is private
/home/.ssh/*
!/home/.ssh/config
" >> "$1/.gitignore"
  else
    printf "Repository directory not specified.\n"
  fi
}
# _init_git_repository()
#
# Initialize the git repository at $DOTSPATH
#
# called by: init()
_init_git_repository() {
  if [[ -n "$1" ]]; then
    cd "$1"
    $_git_bin init
  else
    printf "Repository directory not specified.\n"
  fi
}
# _init_post_message()
#
# Print information about what just happened and some next steps.
#
# called by: init()
_init_post_message() {
  if [[ -n "$1" ]]; then
    printf "\
         _       _
        | |     | |
      __| | ___ | |_ ___
     / _\` |/ _ \\| __/ __|
    | (_| | (_) | |_\\__ \\
     \\__,_|\\___/ \\__|___/

Your dotfile git repo has been initialized at the following location:

%s

To finish installation, add the following to your shell configuration (.bashrc, \
.bash_profile, .zshrc, or similar):

if [ -d \"\$HOME/bin\" ]; then
  PATH=\"\$HOME/bin:\$PATH\"
fi
" "$1"
  else
    printf "Repository directory not specified.\n"
  fi
}
# init()
#
# Initialize a new repository.
init() {
  # Initialize variables
  #
  # $init_souce: will be set to a source git repository URL if available.
  init_source=
  # A URL-matching regex to check arguments for a source git repository.
  _regex='(https?|git|ssh|file)://[-A-Za-z0-9\+&@#/%?=~_|!:,.;]*[-A-Za-z0-9\+&@#/%=~_|]'

  # Create $HOME/bin if it doesn't exist.
  if [[ ! -e "$HOME/bin" ]]; then
    mkdir "$HOME/bin"
  fi

  # Handle arguments.
  #
  # Expected behavior:
  #   init [<source_repository>] [<dotspath>]
  if [[ -n "$1" ]]; then
    if [[ "$1" =~ $_regex ]]; then
      init_source="$1"
      if [[ -n "$2" ]]; then
        DOTSPATH="$2"
        _init_dotsrc "$DOTSPATH"
      fi
    else
      DOTSPATH="$1"
      _init_dotsrc "$DOTSPATH"
    fi
  fi
  _debug printf "init() \$DOTSPATH: %s\n" "$DOTSPATH"
  _debug printf "init() \$init_source: %s\n" "$init_source"

  # Initialize either from source or with fresh directory structure.
  if [[ ! -e "$DOTSPATH" ]]; then
    if [[ -n "$init_source" ]]; then
      _init_with_source "$DOTSPATH" "$init_source"
    else
      _init_directory_structure "$DOTSPATH"
      _init_gitignore "$DOTSPATH"
      _init_git_repository "$DOTSPATH"
    fi
    _init_post_message "$DOTSPATH"
  else
    _die printf "\
A file or directory already exists at the dotfile repository path:
%s\n" "$DOTSPATH"
  fi
}

# git #########################################################################

# ------------------------------------------------------------------------- git

desc "git" <<EOM
Usage:
  $_ME git command [--options] [<arguments>]

Description:
  Run a git command within the \$DOTSPATH directory.
EOM
git() {
  # Perform git operations in the $DOTSPATH directory.
  cd "$DOTSPATH"

  # Set $IFS to default for better argument handling.
  IFS="$DEFAULT_IFS"

  # Use raw options to get the option string, with some parts stripped.
  git_options=($(printf "%s" "$_RAW_OPTIONS" | \
    tr '\n' ' ' | \
    sed -e 's/--debug//' | \
    sed -e 's/^git //'     \
  ))

  # call the environment's git with the git options passed as an array.
  $_git_bin "${git_options[@]}"
}

# ---------------------------------------------------------------------- commit

desc "commit" <<EOM
Usage:
  $_ME commit [<message>]

Description:
  Commit the current changes to git. If a message is provided, it will be used
  as the commit message. Otherwise, git will open your default editor.
EOM
commit() {
  cd "$DOTSPATH"
  if [[ -n "$1" ]]; then
    $_git_bin add .
    $_git_bin commit -a -m "$1"
  else
    $_git_bin add .
    $_git_bin commit -a
  fi
}

# ------------------------------------------------------------------------ pull

desc "pull" <<EOM
Usage:
  $_ME pull

Description:
  Pull latest changes from the remote repository.
EOM
pull() {
  cd "$DOTSPATH"
  $_git_bin pull
  _debug printf "%s pull\n" "$_git_bin"
}

# ------------------------------------------------------------------------ push

desc "push" <<EOM
Usage:
  $_ME push

Description:
  Push local commits to the remote repository.
EOM
push() {
  cd "$DOTSPATH"
  $_git_bin push
  _debug printf "%s push\n" "$_git_bin"
}

# ------------------------------------------------------------------ submodules

desc "submodules" <<EOM
Usage:
  $_ME submodules ( sync | update )

Subcommands:
  sync    Sync all submodules with the current head commit. This usually be
          should be performed after a \`dots pull\`. Equivalent git command:
            git submodule update --recursive --init
  update  Update all first-level submodules to the latest commit in each
          submodule's origin repository. Equivalent git command:
            git submodule update --init --remote
EOM
submodules() {
  cd "$DOTSPATH"
  case "$1" in
    sync)
      "$_git_bin" submodule update --init --recursive
      ;;
    update)
      "$_git_bin" submodule update --init --remote
      ;;
    *)
      _die printf "Unrecognized subcommand: submodules %s\n" "$1"
      ;;
  esac
}

# Scripts #####################################################################

# ------------------------------------------------------------------- bootstrap

desc "bootstrap" <<EOM
Usage:
  $_ME bootstrap ( list | <script_name> )

Description:
  Run the specified bootstrap script.

  Bootstrap scripts can be added to:
    $DOTSPATH/script/bootstrap/
EOM
bootstrap() {
  # Don't permit use of the --all flag, since it's unlikely that the user
  # intends to run all bootstrap scripts.
  if ( _command_argv_includes "--all" ); then
    _print_desc "bootstrap"
  else
    _runner "bootstrap" "${@:-}"
  fi
}

# --------------------------------------------------------------------- install

desc "install" <<EOM
Usage:
  $_ME install ( --all | list | <script_name> )

Options:
  --all  Run all install scripts.

Description:
  Run the specified package script.

  Package scripts can be added to:
    $DOTSPATH/script/install/
EOM
install() {
  _runner "install" "${@:-}"
}

# ------------------------------------------------------------------- configure

desc "configure" <<EOM
Usage:
  $_ME configure ( --all | list | <configuration_script> )

Options:
  --all  Run all configure scripts.

Description:
  Run the specified package update script.

  Configuration scripts can be added to:
    $DOTSPATH/script/configure/
EOM
configure() {
  _runner "configure" "${@:-}"
}

# ------------------------------------------------------------------- customize

desc "customize" <<EOM
Usage:
  $_ME customize ( --all | list | <customization_script> )

Options:
  --all  Run all customize scripts.

Description:
  Run the specified customization script.

  Customization scripts can be added to:
    $DOTSPATH/script/customize/
EOM
customize() {
  _runner "customize" "${@:-}"
}

# Dotfiles ####################################################################

# ------------------------------------------------------------------------ list

desc "list" <<EOM
Usage:
  $_ME [bin | home] list [tracked | untracked | <filename>]

Description:
  List all files in the original directory of the current context ('bin' or
  'home'). If neither 'bin' nor 'home' is specified, the context defaults to
  'home' (ie, dotfiles).

  If 'tracked' or 'untracked' as passed as arguments to 'list', then only the
  files with those statuses are listed.

  If a filename is passed as an argument, then a listing is printed for only
  that item.

  Indicators display information about the type and status of each entry:
    d   - Directory
    @   - Symbolic link
    @ i - Symbolic link to tracked file.
EOM
_list_item() {
  if [[ -L $f ]]; then
    if [[ "$(readlink "$f")" == "$tracked_file" ]]; then
      printf "@  i   %s\n" "$filename"
    else
      printf "@      %s\n" "$filename"
    fi
  elif [[ -d $f ]]; then
    printf "d      %s\n" "$filename"
  elif [[ -e $f ]]; then
    printf "       %s\n" "$filename"
  fi

}
list() {
  if [[ "$1" == "untracked" ]]; then
    untracked
  elif [[ "$1" == "tracked" ]]; then
    tracked
  elif [[ "$1" =~ ^\.(.*) ]]; then
    f="$original_dir/$1"
    if [[ -e "$f" ]]; then
      filename=$(basename "$f")
      tracked_file=$tracked_dir/$filename
      original_file=$original_dir/$filename
      _list_item
    else
      _die printf "File not found.\n"
    fi
  else
    _each_original_file _list_item
  fi
}

# ------------------------------------------------------------------- untracked

desc "untracked" <<EOM
Usage:
  $_ME [bin | home] untracked

Description:
  List all untracked dotfiles in the original directory of the current context
  ('bin' or 'home'). If neither 'bin' nor 'home' is specified, the context
  defaults to 'home' (ie, dotfiles).

  Indicators display information about the type and status of each entry:
    d   - Directory
    @   - Symbolic link
EOM
_untracked_item() {
  if [[ -L $f ]];then
    if ! ( [[ "$(readlink "$f")" == "$tracked_file" ]] ); then
      printf "@      %s\n" "$filename"
    fi
  elif [[ -d $f ]]; then
    printf "d      %s\n" "$filename"
  elif [[ -e $f ]]; then
    printf "       %s\n" "$filename"
  fi
}
untracked() {
  _each_original_file _untracked_item
}

# --------------------------------------------------------------------- tracked

desc "tracked" <<EOM
Usage:
  $_ME [bin | home] tracked

Description:
  List all tracked dotfiles from in the original directory of the current
  context ('bin' or 'home'). If neither 'bin' nor 'home' is specified, the
  context defaults to 'home' (ie, dotfiles).

  Indicators display information about the type and status of each entry:
    @ i - Symbolic link to tracked file.
EOM
_tracked_item() {
  if ( [[ -L $f ]] && \
       [[ "$(readlink "$f")" == "$tracked_file" ]]
  ); then
    printf "@  i   %s\n" "$filename"
  fi
}
tracked() {
  _each_original_file _tracked_item
}

# ------------------------------------------------------------------------- add

desc "add" <<EOM
Usage:
  $_ME [bin | home] add <filename> [--force]

Options:
  --force  Overwrite files and folders in the repository that have the same
           as the item(s) being added.

Description:
  Add the specified file to the tracked directory for the context ('bin' or
  'home') and link. If neither 'bin' nor 'home' is specified, the context
  defaults to 'home' (ie, dotfiles).
EOM
add() {
  _debug printf "add() \$1: %s\n" "$1"

  if [[ $# = 0 ]]; then
    _die printf "Must specify a valid file or directory name.\n"
  else
    filename=$(basename "$1")

    original_file=$original_dir/$filename
    _debug printf "add() \$original_file: %s\n" "$original_file"

    tracked_file=$tracked_dir/$filename
    _debug printf "add() \$tracked_file: %s\n" "$tracked_file"

    # Because the if / else is complicated, guarding against errors by only
    # proceeding when this variable has been set.
    safe_to_proceed=

    if [[ ! -e $original_file ]]; then
      _die printf "File or directory does not exist.\n"
    elif ( \
      [[ "$filename" == "/"  ]] || \
      [[ "$filename" == "."  ]] || \
      [[ "$filename" == ".." ]]
    ); then
      _die printf "Invalid filename: %s\n" "$filename"
    elif [[ -e $tracked_file ]]; then
      if _command_argv_includes "--force"; then
        printf "Overwriting %s\n" "$tracked_file"
        while true; do
          read -p "Are you sure you want to proceed? [y/n] " yn
          case $yn in
            [Yy]* )
              printf "Removing %s\n" "$tracked_file"
              rm -r "$tracked_file"
              break
              ;;
            [Nn]* )
              printf "Exiting...\n"
              exit
              ;;
            * )
              printf "Please answer yes or no.\n"
              ;;
          esac
        done
        safe_to_proceed=1
      else
        _die printf "File has already been added.\n"
      fi
    elif [[ -L $original_file ]]; then
      _die printf "Original is already a symlink.\n"
    else
      safe_to_proceed=1
    fi
    if [[ -n "$safe_to_proceed" ]]; then
      mv "$original_file" "$tracked_dir"
      printf "Linking %s => %s\n" "$tracked_file" "$original_file"
      ln -s "$tracked_file" "$original_file"
    fi
  fi
}

# --------------------------------------------------------------------- restore

desc "restore" <<EOM
Usage:
  $_ME [bin | home] restore <filename>

Description:
  Unlink the specified file and move from the tracked location in the
  repository back to original location specified by the context ('bin' or
  'home'). If neither 'bin' nor 'home' is specified, the context  defaults to
  'home' (ie, dotfiles).
EOM
restore() {
  _debug printf "restore() \$1: %s\n" "$1"

  if [[ $# = 0 ]]; then
    _die printf "Must specify a valid file or directory name.\n"
  else
    filename=$(basename "$1")

    original_file=$original_dir/$filename
    _debug printf "restore() \$original_file: %s\n" "$original_file"

    tracked_file=$tracked_dir/$filename
    _debug printf "restore() \$tracked_file: %s\n" "$tracked_file"

    if [[ ! -e $tracked_file ]]; then
      printf "File does not exist.\n"
    elif [[ ! -L $original_file ]]; then
      printf "File is not a symlink.\n"
    else
      rm "$original_file"
      mv "$tracked_file" "$original_file"
      printf "Restored: %s => %s\n" "$tracked_file" "$original_file"
    fi
  fi
}

# ---------------------------------------------------------------------- status

desc "status" <<EOM
Usage:
  $_ME [bin | home] status

Description:
  List status of files in original directory of the current context ('bin' or
  'home')relative to the corresponding tracked file. If neither 'bin' nor 'home'
  is specified, the context defaults to 'home' (ie, dotfiles).

  Indicators display information about the status of each entry:
    i   - Identical, indicating a valid symbolic link to the tracked file
     e  - A file exists, but it not linked to tracked file
      x - No file exists
EOM
_status_item() {
  if ( [[ -L $original_file ]] && \
       [[ "$(readlink "$original_file")" == "$f" ]]
  ); then
    printf "i   %s\n" "$filename"
  elif [[ -e $original_file ]]; then
    printf " e  %s\n" "$filename"
  else
    printf "  x %s\n" "$filename"
  fi
}
status() {
  _each_tracked_file _status_item
}

# ------------------------------------------------------------------------ link

desc "link" <<EOM
Usage:
  $_ME [bin | home] link [<filename>] [--overwrite [--with-backup]]

Options:
  --overwrite    Overwrite any files that exist in the directory where links
                 are being created, meaning that any conflicting files will be
                 deleted and links to the corresponding repository file will
                 be created.
  --with-backup  When used in combination with --overwrite, any overwritten
                 files are first renamed with a '.bak' extension. If a file
                 with the same name plus '.bak' extension already exists,
                 nothing is done to this file and no link is created.

Description:
  Create a link in the original directory for the context ('bin' or 'home')
  that references the corresponding item in the tracked directory. If neither
  'bin' nor 'home' is specified, the context defaults to 'home' (ie, dotfiles).

  By default the command links all files that exist in the tracked directory.
  If a filename is passed to the link command, then it only acts on that file.
EOM
_link_item() {
  if [[ -e $original_file ]]; then
    if _command_argv_includes "--overwrite" ; then
      if _command_argv_includes "--with-backup"; then
        if [[ -e "$original_file".bak ]]; then
          printf "Exists with .bak: %s, %s\n" "$filename" "$filename".bak
          return 0
        else
          mv "$original_file" "$original_file".bak
        fi
      else
        rm "$original_file"
      fi
    else
      printf "Exists: %s\n" "$filename"
      return 0
    fi
  fi
  printf "Linking %s => %s\n" "$f" "$original_file"
  ln -s "$f" "$original_file"
}
link() {
  if [[ -n "$1" ]]; then
    f="$tracked_dir/$1"
    filename=$(basename "$1")
    tracked_file=$tracked_dir/$filename
    original_file=$original_dir/$filename
    if [[ -e "$tracked_file" ]]; then
      _link_item
    fi
  else
    _each_tracked_file _link_item
  fi
}

# ---------------------------------------------------------------------- unlink

desc "unlink" <<EOM
Usage:
  $_ME [bin | home] unlink [<filename>]

Description:
  Remove symlinks in the original directory for the context ('bin' or 'home').
  If neither 'bin' nor 'home' is specified, the context defaults to 'home' (ie,
  dotfiles).

  By default, the command removes all of the symlinks pointing to items in
  tracked directory. If a filename is passed to the unlink command, then it
  only acts on symlinks to that file.
EOM
_unlink_item() {
  if ( [[ -L $original_file ]] && \
       [[ "$(readlink "$original_file")" == "$f" ]]
  ); then
    printf "Removing link: %s\n" "$original_file"
    rm "$original_file"
  fi
}
unlink() {
  if [[ -n "$1" ]]; then
    f="$tracked_dir/$1"
    filename=$(basename "$1")
    tracked_file=$tracked_dir/$filename
    original_file=$original_dir/$filename
    _unlink_item
  else
    _each_tracked_file _unlink_item
  fi
}

# ---------------------------------------------------------------------- rename

desc "rename" <<EOM
Usage:
  $_ME [bin | home] rename <old_filename> <new_filename>

Decription:
  Rename a tracked file and its corresponding link in the specified context. If
  neither 'bin' nor 'home' is specified, the context defaults to 'home' (ie,
  dotfiles).
EOM
rename() {
  old_file=$tracked_dir/$1
  _debug printf "rename() \$old_file: %s\n" "$old_file"
  new_file=$tracked_dir/$2
  _debug printf "rename() \$new_file: %s\n" "$new_file"

  if [[ -z "$1" ]]; then
    printf "Filename not provided.\n"
  elif [[ -z "$2" ]]; then
    printf "New name not provided.\n"
  elif ! ( [[ -e "$old_file" ]] ); then
    printf "File not found.\n"
  elif ( [[ -e "$new_file" ]] ); then
    printf "A file already exists with the new filename.\n"
  else
    unlink "$1"
    _debug printf "unlink %s\n" "$1"

    mv "$old_file" "$new_file"
    _debug printf "mv %s %s\n" "$old_file" "$new_file"

    link "$2"
    _debug printf "link %s\n" "$2"
  fi
}

# Utilties ####################################################################

# ------------------------------------------------------------------------ edit

desc "edit" <<EOM
Usage:
  $_ME edit
  $_ME [bin | home] edit [<filename>]

Description:
  Open a tracked file or, when no filename is specified, the entire tracked
  repository in you \$EDITOR, currently set to '$EDITOR'.
EOM
edit() {
  [[ -z "$EDITOR" ]] && _die printf "\$EDITOR is not set.\n"
  if [[ -n "$1" ]]; then
    f="$tracked_dir/$1"
    filename=$(basename "$1")
    tracked_file=$tracked_dir/$filename
    $EDITOR "$tracked_file"
  else
    $EDITOR "$DOTSPATH"
  fi
}

# ------------------------------------------------------------------------- dir

desc "dir" <<EOM
Usage:
  $_ME dir

Description:
  Print the current value of \$DOTSPATH
EOM
dir() {
  printf "%s\n" "$DOTSPATH"
}

###############################################################################
# Run Program
###############################################################################

# Call the _main function after everything has been defined.
_main

